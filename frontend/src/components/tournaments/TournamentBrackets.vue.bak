<template>
  <div class="tournament-brackets">
    <div class="header-section">
      <div class="actions">
        <button class="back-button" @click="goBack">
          <ArrowLeftIcon size="16" />
          Back
        </button>
        <div class="zoom-controls">
          <button @click="handleZoomOut" :disabled="zoomLevel <= MIN_ZOOM">
            <ZoomOut size="16" />
          </button>
          <span>{{ zoomLevel }}%</span>
          <button @click="handleZoomIn" :disabled="zoomLevel >= MAX_ZOOM">
            <ZoomIn size="16" />
          </button>
        </div>
      </div>
      
      <h2>{{ tournamentName || 'Tournament Brackets' }}</h2>
      
      <div v-if="getTournamentProgress > 0" class="tournament-progress">
        <div class="progress-bar">
          <div class="progress-fill" :style="{ width: `${getTournamentProgress}%` }"></div>
        </div>
        <div class="progress-stats">
          <span>{{ Math.round(getTournamentProgress) }}% Complete</span>
          <span v-if="getRemainingMatches > 0">{{ getRemainingMatches }} matches remaining</span>
        </div>
      </div>
    </div>

    <div class="bracket-container" ref="bracketContainerRef" :style="{ zoom: `${zoomLevel}%` }">
      <div v-if="loading" class="loading">
        <Loader2Icon class="animate-spin" />
        <span>Loading tournament bracket...</span>
      </div>
      
      <div v-else-if="error" class="error-message">
        {{ error }}
      </div>
      
      <div v-else class="tournament-bracket" :class="{ 'empty': rounds.length === 0 }">
        <!-- For each round -->
        <div v-for="(round, roundIndex) in rounds" :key="`round-${roundIndex}`" class="round">
          <h3 class="round-title">{{ getRoundName(roundIndex + 1, round.matches.length) }}</h3>
          
          <!-- For each match in round -->
          <div v-for="(match, matchIndex) in round.matches" 
               :key="`match-${roundIndex}-${matchIndex}`" 
               class="match-card"
               :class="[getMatchCardColor(match), getMatchCardBorder(match)]">
            
            <!-- Team 1 -->
            <div class="team" :class="{ 'winner': match.winner?.id === match.team1?.id, 'bye': match.team1?.id === 'BYE' }">
              <span class="team-name">{{ match.team1?.name || 'TBD' }}</span>
              <input 
                v-if="match.team1 && match.team1.id !== 'BYE'" 
                v-model="match.score1" 
                type="number" 
                min="0" 
                @input="updateMatch(roundIndex, matchIndex, 'score1')" 
                :disabled="!match.team1 || match.team1.id === 'BYE'"
              />
            </div>
            
            <!-- Team 2 -->
            <div class="team" :class="{ 'winner': match.winner?.id === match.team2?.id, 'bye': match.team2?.id === 'BYE' }">
              <span class="team-name">{{ match.team2?.name || 'TBD' }}</span>
              <input 
                v-if="match.team2 && match.team2.id !== 'BYE'" 
                v-model="match.score2" 
                type="number" 
                min="0" 
                @input="updateMatch(roundIndex, matchIndex, 'score2')" 
                :disabled="!match.team2 || match.team2.id === 'BYE'"
              />
            </div>
            
            <!-- Match details -->
            <div class="match-details" v-if="match.completed">
              <span v-if="match.winner" class="winner-label">Winner: {{ match.winner.name }}</span>
            </div>
          </div>
        </div>
        
        <!-- Placeholder when no bracket is generated -->
        <div v-if="rounds.length === 0" class="empty-state">
          <p>No tournament bracket available</p>
        </div>
      </div>
    </div>
    
    <div class="actions-footer">
      <button @click="saveTournamentChanges" class="save-button">
        <Save size="16" />
        Save Changes
      </button>
      <button @click="publishTournament" class="publish-button">
        <Send size="16" />
        Publish Tournament
      </button>
    </div>
  </div>
</template>

<script>
import { ref, computed, reactive, onMounted, watch } from 'vue';
import { ArrowLeftIcon, Save, Send, ZoomIn, ZoomOut, Loader2Icon } from 'lucide-vue-next';
import { useRoute, useRouter } from 'vue-router';

// --- Configuration ---
// IMPORTANT: Replace with your actual backend API URL if deploying
const API_URL = 'http://localhost:5000/api';
const ZOOM_STEP = 10;
const MIN_ZOOM = 50;
const MAX_ZOOM = 150;

export default {
  name: 'TournamentBrackets',
  components: {
    ArrowLeftIcon, Save, Send, ZoomIn, ZoomOut, Loader2Icon
  },
  setup() {
    const route = useRoute();
    const router = useRouter();

    // Refs for DOM elements
    const teamInputRef = ref(null);
    const bracketContainerRef = ref(null);

    // Component state
    const teams = ref([]);
    const teamName = ref('');
    const rounds = ref([]);
    const bracketGenerated = ref(false);
    const zoomLevel = ref(100);
    const activeTab = ref('bracket'); // Default to bracket view
    const loading = ref(false);
    const tournamentName = ref('');
    const error = ref(null); // For displaying errors

    // Tournament stats
    const tournamentStats = reactive({
      topScorer: { name: '', goals: 0 },
      mvp: '',
      playerOfTournament: '',
      firstPlace: null,
      secondPlace: null,
      thirdPlace: null
    });

    // --- Helper Functions ---

    // Calculate the number of rounds needed (power of 2)
    const calculateRounds = (numTeams) => {
       if (numTeams < 2) return 0;
       return Math.ceil(Math.log2(numTeams));
    };

    // Calculate number of byes needed
    const calculateByes = (numTeams) => {
        if (numTeams < 2) return 0;
        const numRounds = calculateRounds(numTeams);
        const totalSlots = Math.pow(2, numRounds);
        return totalSlots - numTeams;
    };

    // Get round name for display (handles Finals, Semis, Quarters)
    const getRoundName = (roundNumber, numMatchesInRound) => {
      const totalRounds = rounds.value.length;
      if (roundNumber === totalRounds) return 'Championship Final';
      // If only one match in the second to last round, it's the only Semi-Final
      if (roundNumber === totalRounds - 1 && numMatchesInRound === 1) return 'Semi-Final';
      if (roundNumber === totalRounds - 1) return 'Semi-Finals';
      if (roundNumber === totalRounds - 2) return 'Quarter-Finals';
      return `Round ${roundNumber}`;
    };

     // Get round name for the preview structure
    const getRoundNamePreview = (roundNumber) => {
        const numTeams = teams.value.length;
        if (numTeams < 2) return `Round ${roundNumber}`;
        const totalRounds = calculateRounds(numTeams);

        if (roundNumber === totalRounds) return 'Final';
        if (roundNumber === totalRounds - 1) return 'Semi-Finals';
        if (roundNumber === totalRounds - 2) return 'Quarter-Finals';
        return `Round ${roundNumber}`;
    };

    // --- Core Logic: Team Management ---

    const addTeam = () => {
      const trimmedName = teamName.value.trim();
      if (trimmedName === '') return;
      // Prevent adding duplicate names (case-insensitive check)
      if (teams.value.some(team => team.name.toLowerCase() === trimmedName.toLowerCase())) {
         alert(`Team "${trimmedName}" already exists.`);
         return;
      }
      if (bracketGenerated.value) {
        // Optional: Decide if adding teams should reset the bracket
        // For now, let's prevent adding teams after generation without explicit reset
         alert("Cannot add teams after bracket is generated. Please reset if needed.");
         return;
        // Or reset:
        // resetBracket(); // Reset everything
        // teams.value = []; // Clear teams too if needed
      }
      teams.value.push({ id: `team-${Date.now()}-${Math.random()}`, name: trimmedName }); // Use a more unique temporary ID
      teamName.value = '';

      // Focus back on the input
      teamInputRef.value?.focus();
    };

    const handleKeyDown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault(); // Prevent form submission if inside one
        addTeam();
      }
    };

    // --- Core Logic: Bracket Generation & Propagation ---

    /**
     * Propagates winners from a completed round to the next round's matches.
     * This is used both after initial generation (for byes) and after loading data.
     * @param {Array} targetRounds - The rounds array to process.
     */
    const propagateWinners = (targetRounds) => {
        console.log("Running propagation...");
        if (!targetRounds || targetRounds.length < 2) return; // Nothing to propagate

        // For each round except the last one
        for (let i = 0; i < targetRounds.length - 1; i++) {
            const currentRound = targetRounds[i];
            const nextRound = targetRounds[i + 1];
            
            // Skip the 3rd place match when propagating winners
            const nextRoundMatches = nextRound.matches.filter(match => !match.isThirdPlace);
            
            // For each match in current round
            currentRound.matches.forEach((match, matchIndex) => {
                if (match.winner) {
                    // Calculate the index in the next round
                    const nextRoundMatchIndex = Math.floor(matchIndex / 2);
                    
                    // Ensure we're not exceeding the nextRoundMatches array
                    if (nextRoundMatchIndex < nextRoundMatches.length) {
                        // Determine if this match feeds into team1 or team2 spot
                        if (matchIndex % 2 === 0) {
                            nextRoundMatches[nextRoundMatchIndex].team1 = match.winner;
                            // Check if we just created a bye match in the next round
                            if (nextRoundMatches[nextRoundMatchIndex].team1 && 
                                (!nextRoundMatches[nextRoundMatchIndex].team2 || 
                                 (nextRoundMatches[nextRoundMatchIndex].team2 && 
                                 nextRoundMatches[nextRoundMatchIndex].team2.id === 'BYE'))) {
                                nextRoundMatches[nextRoundMatchIndex].hasBye = true;
                                nextRoundMatches[nextRoundMatchIndex].winner = nextRoundMatches[nextRoundMatchIndex].team1;
                                nextRoundMatches[nextRoundMatchIndex].completed = true;
                                nextRoundMatches[nextRoundMatchIndex].score1 = 0;
                                nextRoundMatches[nextRoundMatchIndex].score2 = 0;
                            }
                        } else {
                            nextRoundMatches[nextRoundMatchIndex].team2 = match.winner;
                            // Check if we just created a bye match in the next round
                            if (nextRoundMatches[nextRoundMatchIndex].team2 && 
                                nextRoundMatches[nextRoundMatchIndex].team1 && 
                                nextRoundMatches[nextRoundMatchIndex].team2.id === 'BYE') {
                                nextRoundMatches[nextRoundMatchIndex].hasBye = true;
                                nextRoundMatches[nextRoundMatchIndex].winner = nextRoundMatches[nextRoundMatchIndex].team1;
                                nextRoundMatches[nextRoundMatchIndex].completed = true;
                                nextRoundMatches[nextRoundMatchIndex].score1 = 0;
                                nextRoundMatches[nextRoundMatchIndex].score2 = 0;
                            }
                        }
                    }
                }
            });
        }
        console.log("Propagation finished.");
        // Update tournament positions after propagation is complete
        updateTournamentPositions();
    };

    const generateBracket = () => {
      if (teams.value.length < 2) {
        alert('Please add at least 2 teams');
        return;
      }

      console.log("Generating bracket for teams:", teams.value);
      const numTeams = teams.value.length;
      const numRounds = calculateRounds(numTeams);
      const totalSlots = Math.pow(2, numRounds);
      const generatedRounds = [];

      // --- Create Round 1 (Handles Byes) ---
      const firstRoundMatches = [];
      const teamsCopy = [...teams.value]; // Use a copy

      for (let i = 0; i < totalSlots / 2; i++) {
        const matchId = `R1-M${i+1}`;
        const team1Index = i;
        const team2Index = totalSlots - 1 - i; // Standard seeding pair (top vs bottom)

        const team1 = team1Index < teamsCopy.length ? teamsCopy[team1Index] : null;
        const team2 = team2Index < teamsCopy.length ? teamsCopy[team2Index] : null;

        const hasBye = team1 !== null && team2 === null;

        const match = {
          id: matchId,
          matchName: `Round 1      Match ${i+1}${hasBye ? ' (Bye)' : ''}`,
          team1: team1,
          team2: team2, // Null if bye
          score1: 0,
          score2: 0,
          winner: hasBye ? team1 : null, // Set winner for bye immediately
          pk1: null,
          pk2: null,
          hasPK: false,
          date: '',
          time: '',
          topScorer: { name: '', goals: 0 },
          hasBye: hasBye,
          completed: hasBye // Mark bye as completed
        };
        firstRoundMatches.push(match);
      }
      generatedRounds.push({ round: 1, matches: firstRoundMatches });

      // --- Create Subsequent Rounds (Structure Only) ---
      for (let r = 2; r <= numRounds; r++) {
        const roundMatches = [];
        const prevRoundMatchCount = generatedRounds[r - 2].matches.length;
        const currentRoundMatchCount = prevRoundMatchCount / 2;

        for (let i = 0; i < currentRoundMatchCount; i++) {
          // Determine match name based on round
           let matchName = getRoundName(r, currentRoundMatchCount)
           if (r !== numRounds && currentRoundMatchCount > 1) {
               matchName += `      Match ${i+1}`; // Add index if not final and multiple matches
           }

          const match = {
            id: `R${r}-M${i+1}`,
            matchName: matchName,
            team1: null, team2: null, // Start empty
            score1: 0, score2: 0, winner: null,
            pk1: null, pk2: null, hasPK: false,
            date: '', time: '',
            topScorer: { name: '', goals: 0 },
            hasBye: false, // Only round 1 has byes
            completed: false
          };
          roundMatches.push(match);
        }
        generatedRounds.push({ round: r, matches: roundMatches });
      }

      // --- Add 3rd place match if we have semifinal round ---
      if (numRounds >= 3) {
        // Create a special round for 3rd place match
        const thirdPlaceRound = {
          round: numRounds, // Same round number as final for display purposes
          matches: [{
            id: `R${numRounds}-3rd`,
            matchName: `3rd Place Match`,
            team1: null, // Will be filled with semifinal losers
            team2: null, // Will be filled with semifinal losers
            score1: 0,
            score2: 0,
            pk1: null,
            pk2: null,
            hasPK: false,
            winner: null,
            completed: false,
            hasBye: false,
            isThirdPlace: true, // Mark as third place match
            topScorer: { name: '', goals: 0 },
            date: '',
            time: '',
            match: 'third'
          }]
        };
        generatedRounds.push(thirdPlaceRound);
      }

      // --- Propagate Bye Winners Immediately ---
      propagateWinners(generatedRounds); // Pass the newly created structure

      // --- Final State Update ---
      rounds.value = generatedRounds;
      bracketGenerated.value = true;
      activeTab.value = 'bracket'; // Switch to bracket view
      console.log("Bracket generation complete. Final structure:", JSON.parse(JSON.stringify(rounds.value)));
    };

    // --- Core Logic: Match Updates ---

    const updateMatch = (roundIndex, matchIndex, field) => {
      const match = rounds.value[roundIndex].matches[matchIndex];

      // Ensure scores are numbers
      if (field === 'score1' || field === 'score2') {
         match[field] = Math.max(0, parseInt(match[field] || 0, 10));
      }
      if (field === 'pk1' || field === 'pk2') {
         match[field] = match[field] === null ? null : Math.max(0, parseInt(match[field] || 0, 10));
      }

      // --- Determine Winner ---
      let newWinner = null;
      let isComplete = false;

      if (match.hasBye && match.team1) {
        match.winner = match.team1;
        match.completed = true;
        match.score1 = 0;
        match.score2 = 0;
      } else if (match.team1 && match.team2) {
        if (match.score1 > match.score2) {
          newWinner = match.team1;
          isComplete = true;
        } else if (match.score2 > match.score1) {
          newWinner = match.team2;
          isComplete = true;
        } else if (match.score1 === match.score2 && !match.score1 === 0 && !match.score2 === 0) {
          // If scores are equal (and not 0-0), check PK
          if (match.pk1 !== null && match.pk2 !== null) {
            if (match.pk1 > match.pk2) {
              newWinner = match.team1;
              isComplete = true;
            } else if (match.pk2 > match.pk1) {
              newWinner = match.team2;
              isComplete = true;
            } else {
              newWinner = null;
              isComplete = false;
            }
          } else {
            newWinner = null;
            isComplete = false;
          }
        } else {
          newWinner = null;
          isComplete = false;
        }
      } else {
        newWinner = null;
        isComplete = false;
      }

      // --- Update Match State ---
      const winnerChanged = match.winner?.id !== newWinner?.id;
      match.winner = newWinner;
      match.completed = isComplete;

      // --- Propagate Winner to Next Round if Changed ---
      if (winnerChanged || (isComplete && newWinner)) { // Propagate if winner changes OR if newly completed with a winner
          if (roundIndex < rounds.value.length - 1) {
              const nextRoundIndex = roundIndex + 1;
              const nextMatchIndex = Math.floor(matchIndex / 2);
              const nextMatch = rounds.value[nextRoundIndex].matches[nextMatchIndex];
              const isFirstFeeder = matchIndex % 2 === 0;

              if (isFirstFeeder) {
                  nextMatch.team1 = newWinner; // Assign winner (or null if undecided)
              } else {
                  nextMatch.team2 = newWinner; // Assign winner (or null if undecided)
              }

              // If a team is removed (e.g., score changed back to draw), reset the next match's scores/winner too
              if (!newWinner || winnerChanged) {
                 nextMatch.score1 = 0;
                 nextMatch.score2 = 0;
                 nextMatch.winner = null;
                 nextMatch.pk1 = null;
                 nextMatch.pk2 = null;
                 nextMatch.hasPK = false;
                 nextMatch.completed = false;
                 // Recursively clear further rounds if needed (optional, can get complex)
              }
          }
      }
      // Trigger reactivity (though direct mutation should work with Vue 3 Proxy)
      // rounds.value = [...rounds.value];
    };

    const updateDateTime = (roundIndex, matchIndex, field, value) => {
       // Basic assignment, could add validation later
       rounds.value[roundIndex].matches[matchIndex][field] = value;
    };

    const updateMatchTopScorer = (roundIndex, matchIndex, field, value) => {
        const match = rounds.value[roundIndex].matches[matchIndex];
        if (field === 'goals') {
             match.topScorer.goals = Math.max(0, parseInt(value || 0, 10));
        } else {
            match.topScorer.name = value;
        }
        // Optional: Automatically update overall tournament top scorer here
        // updateTournamentTopScorer();
    };

    // --- Core Logic: Stats Management ---

    // Update tournament's overall top scorer based on current stats inputs
    // Note: This version relies on manual input in the stats tab.
    // To make it automatic based on *match* top scorers, you'd need a different function.
    const updateTopScorerName = (e) => {
      tournamentStats.topScorer.name = e.target.value;
    };

    const updateTopScorerGoals = (e) => {
      tournamentStats.topScorer.goals = Math.max(0, parseInt(e.target.value || 0, 10));
    };

    // --- Core Logic: Data Loading ---

    const fetchTournamentBracket = async (id) => {
      loading.value = true;
      error.value = null; // Reset error before fetch
      console.log(`Fetching bracket for tournament ID: ${id}`);
      try {
        const token = localStorage.getItem('token'); // Assuming token auth
        if (!token) {
          throw new Error('Authentication token not found. Please log in.');
        }
        const response = await fetch(`${API_URL}/tournaments/${id}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json' // Good practice
          }
        });

        if (!response.ok) {
          const errData = await response.json().catch(() => ({ message: `HTTP error! Status: ${response.status}` })); // Graceful error handling
          throw new Error(errData.message || `Failed to fetch tournament data. Status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Fetched tournament data:', data);

        tournamentName.value = data.name || 'Tournament'; // Default name

        // --- Process Registered Teams ---
        // Use registeredTeamsDetails which should be populated by the backend
        if (data.registeredTeamsDetails && data.registeredTeamsDetails.length > 0) {
            teams.value = data.registeredTeamsDetails.map(teamDetail => ({
                // Ensure mapping is correct based on backend structure
                id: teamDetail._id, // Use Registration _id or Team _id if available
                name: teamDetail.teamName || 'Unnamed Team'
            }));
            console.log("Processed teams:", teams.value);
        } else {
            teams.value = []; // No teams registered or provided
            console.log("No registered teams found in data.");
        }

        // --- Process Bracket Data ---
        if (data.bracket && data.bracket.rounds && data.bracket.rounds.length > 0) {
            const rawRounds = data.bracket.rounds;
            const processedRounds = rawRounds.map((roundMatches, roundIndex) => {
                const currentRoundMatchCount = roundMatches.length;
                return {
                    round: roundIndex + 1,
                    matches: roundMatches.map((matchData, matchIndex) => {
                        // Lookup team details using the populated teams.value
                        // Handles potential string IDs or object refs from backend
                        const findTeam = (teamRef) => {
                             if (!teamRef) return null;
                             const teamId = typeof teamRef === 'object' ? teamRef._id : teamRef;
                             if (teamId === 'BYE') return { id: 'BYE', name: 'Bye' }; // Handle BYE explicitly
                             return teams.value.find(t => t.id === teamId);
                        };

                        const team1 = findTeam(matchData.team1);
                        const team2 = findTeam(matchData.team2);
                        const winner = findTeam(matchData.winner); // Winner is likely just an ID string

                        // Generate a unique ID for Vue key
                        const vueMatchId = `R${roundIndex + 1}-M${matchData.match || (matchIndex + 1)}`;
                        const hasBye = team2?.id === 'BYE';

                        // Determine match name
                        let matchName = getRoundName(roundIndex + 1, currentRoundMatchCount);
                        if ((roundIndex + 1) !== calculateRounds(teams.value.length) && currentRoundMatchCount > 1) {
                             matchName += `      Match ${matchData.match || (matchIndex + 1)}`;
                        }
                        if (hasBye) matchName += ' (Bye)';

                        return {
                            id: vueMatchId,
                            matchName: matchName,
                            team1: team1, // Populated team object or null
                            team2: team2, // Populated team object, 'Bye' object, or null
                            winner: winner, // Populated team object or null
                            hasBye: hasBye,
                            // --- Scores & Details (provide defaults) ---
                            score1: matchData.score1 ?? 0,
                            score2: matchData.score2 ?? 0,
                            pk1: matchData.pk1 ?? null,
                            pk2: matchData.pk2 ?? null,
                            hasPK: matchData.hasPK ?? false,
                            completed: matchData.completed ?? hasBye ?? (!!winner), // Mark complete if winner exists or it's a bye
                            topScorer: matchData.topScorer ? { // Ensure object structure
                                 name: matchData.topScorer.name || '',
                                 goals: matchData.topScorer.goals || 0
                             } : { name: '', goals: 0 },
                            date: matchData.date ? matchData.date.split('T')[0] : '', // Format date if needed
                            time: matchData.time || '',
                            // Include original match number if provided
                            originalMatchNumber: matchData.match
                        };
                    })
                };
            });

            // --- Assign Processed Rounds & Propagate ---
            rounds.value = processedRounds;
            propagateWinners(rounds.value); // Ensure teams are placed correctly based on loaded winners
            bracketGenerated.value = true;
            console.log('Bracket loaded and propagated from fetched data.');

            // --- Load Stats ---
            if (data.stats) {
                tournamentStats.topScorer = data.stats.topScorer ? {
                    name: data.stats.topScorer.name || '',
                    goals: data.stats.topScorer.goals || 0
                } : { name: '', goals: 0 };
                tournamentStats.mvp = data.stats.mvp || '';
                tournamentStats.playerOfTournament = data.stats.playerOfTournament || '';
            } else {
                // Reset stats if not provided
                 Object.assign(tournamentStats, { topScorer: { name: '', goals: 0 }, mvp: '', playerOfTournament: '' });
            }

        } else if (teams.value.length >= 2) {
           console.log('No existing bracket found in data, generating new one based on registered teams.');
           generateBracket(); // Generate fresh if no data but teams exist
        } else {
           console.log('No bracket data found and not enough registered teams.');
           bracketGenerated.value = false; // Stay on setup screen
        }

      } catch (err) {
        console.error('Error fetching or processing tournament bracket:', err);
        error.value = err.message || 'An unexpected error occurred.';
        // Potentially reset state or guide user
        bracketGenerated.value = false;
        rounds.value = [];
        teams.value = []; // Clear teams on major fetch error? Maybe not.
      } finally {
        loading.value = false;
      }
    };

    // --- UI Controls ---

    const goBack = () => {
      // Check if changes were made? (More complex state management needed)
      router.back(); // Simple back navigation
    };

    const handleZoomIn = () => {
      zoomLevel.value = Math.min(zoomLevel.value + ZOOM_STEP, MAX_ZOOM);
    };

    const handleZoomOut = () => {
      zoomLevel.value = Math.max(zoomLevel.value - ZOOM_STEP, MIN_ZOOM);
    };

    const resetBracket = () => {
        if (confirm("Are you sure you want to reset the bracket? All match data will be lost.")) {
             teams.value = []; // Clear teams as well for a full reset
             teamName.value = '';
             rounds.value = [];
             bracketGenerated.value = false;
             Object.assign(tournamentStats, { topScorer: { name: '', goals: 0 }, mvp: '', playerOfTournament: '', firstPlace: null, secondPlace: null, thirdPlace: null });
             activeTab.value = 'bracket';
             zoomLevel.value = 100;
             error.value = null;
             // If it was a loaded tournament, redirect or clear ID?
             if (route.params.id) {
                  router.replace({ name: route.name, params: { id: undefined } }); // Go back to create mode URL
             }
             // Focus input after reset allows it
             watch(bracketGenerated, (newVal, oldVal) => {
                 if (!newVal && oldVal && teamInputRef.value) {
                     setTimeout(() => teamInputRef.value?.focus(), 0);
                 }
             }, { immediate: true, flush: 'post' }); // Ensure focus happens after DOM update
        }
    };

    const saveTournamentChanges = () => {
      // Implement save functionality
      console.log("Saving tournament changes...");
      // If there's an existing tournament ID
      if (route.params.id) {
        // Call an API to update the tournament
        try {
          // Display success message (could use a toast notification here)
          alert("Tournament changes saved successfully!");
        } catch (error) {
          console.error("Error saving tournament:", error);
          alert("Failed to save tournament changes. Please try again.");
        }
      } else {
        // If it's a new tournament, we could save it to the database
        alert("Tournament saved successfully!");
      }
    };

    const publishTournament = () => {
      // Implement publish functionality
      console.log("Publishing tournament...");
      if (confirm("Are you sure you want to publish this tournament? Once published, it will be visible to all users.")) {
        try {
          // Add code to publish the tournament (e.g., setting a published flag)
          alert("Tournament published successfully!");
        } catch (error) {
          console.error("Error publishing tournament:", error);
          alert("Failed to publish tournament. Please try again.");
        }
      }
    };

    // --- Computed Properties ---

    const getTotalMatches = computed(() => {
      return rounds.value.reduce((total, round) => {
        return total + round.matches.filter(match => 
          // Don't count matches where both teams are not yet determined
          (match.team1 || match.team2)
        ).length;
      }, 0);
    });

    const getByeCount = computed(() => {
      return rounds.value.reduce((total, round) => {
        return total + round.matches.filter(match => 
          (match.team1 && match.team1.id === 'BYE') || 
          (match.team2 && match.team2.id === 'BYE')
        ).length;
      }, 0);
    });

    // --- Team Goals Computed Property ---
    const teamGoals = computed(() => {
      // Calculate goals for each team
      const goalsByTeam = {};
      
      // Go through all matches and count goals
      rounds.value.forEach(round => {
        round.matches.forEach(match => {
          if (match.team1 && match.score1 !== null) {
            if (!goalsByTeam[match.team1.id]) {
              goalsByTeam[match.team1.id] = { id: match.team1.id, name: match.team1.name, goals: 0 };
            }
            goalsByTeam[match.team1.id].goals += parseInt(match.score1 || 0);
          }
          
          if (match.team2 && match.score2 !== null && match.team2.id !== 'BYE') {
            if (!goalsByTeam[match.team2.id]) {
              goalsByTeam[match.team2.id] = { id: match.team2.id, name: match.team2.name, goals: 0 };
            }
            goalsByTeam[match.team2.id].goals += parseInt(match.score2 || 0);
          }
        });
      });
      
      // Convert to array and sort by goals (descending)
      return Object.values(goalsByTeam).sort((a, b) => b.goals - a.goals);
    });

    const getTournamentProgress = computed(() => {
      if (!rounds.value || rounds.value.length === 0) return 0;
      
      // Filter out bye matches (matches with null team2 or team2.id === 'BYE' that are already completed)
      let allMatches = [];
      rounds.value.forEach(round => {
        round.matches.forEach(match => {
          if (!(match.completed && (!match.team2 || (match.team2 && match.team2.id === 'BYE')))) {
            allMatches.push(match);
          }
        });
      });
      
      const totalMatches = allMatches.length;
      const completedMatches = allMatches.filter(match => match.completed).length;
      
      return totalMatches > 0 ? Math.round((completedMatches / totalMatches) * 100) : 0;
    });

    const getRemainingMatches = computed(() => {
      if (!rounds.value || rounds.value.length === 0) return 0;
      
      let allMatches = [];
      rounds.value.forEach(round => {
        round.matches.forEach(match => {
          if (!(match.completed && (!match.team2 || (match.team2 && match.team2.id === 'BYE')))) {
            allMatches.push(match);
          }
        });
      });
      
      const totalMatches = allMatches.length;
      const completedMatches = allMatches.filter(match => match.completed).length;
      
      return totalMatches - completedMatches;
    });

    // --- Style Helpers ---
    const getMatchCardColor = (match) => {
      if (match.hasBye) return 'from-amber-800/20 to-amber-900/10'; // Darker amber
      if (match.winner) return 'from-emerald-800/20 to-emerald-900/10'; // Darker emerald
      return 'from-gray-700/50 to-gray-800/50';
    };

    const getMatchCardBorder = (match) => {
      if (match.hasBye) return 'border-amber-600/50';
      if (match.winner) return 'border-emerald-600/50';
      return 'border-gray-700/50';
    };

    // --- Update Tournament Positions ---
    const updateTournamentPositions = () => {
      const numRounds = calculateRounds(teams.value.length);
      
      // Find the final match
      const finalRound = rounds.value.find(r => r.round === numRounds && !r.matches[0]?.isThirdPlace);
      if (finalRound && finalRound.matches[0]) {
        const finalMatch = finalRound.matches[0];
        
        // Set 1st and 2nd place based on final match
        if (finalMatch.winner) {
          tournamentStats.firstPlace = finalMatch.winner;
          tournamentStats.secondPlace = finalMatch.team1.id === finalMatch.winner.id ? finalMatch.team2 : finalMatch.team1;
        } else {
          tournamentStats.firstPlace = null;
          tournamentStats.secondPlace = null;
        }
      }
      
      // Find the 3rd place match
      const thirdPlaceMatch = rounds.value.find(r => r.matches.some(m => m.isThirdPlace))?.matches.find(m => m.isThirdPlace);
      if (thirdPlaceMatch) {
        tournamentStats.thirdPlace = thirdPlaceMatch.winner;
      } else {
        tournamentStats.thirdPlace = null;
      }
    };

    // --- Lifecycle Hooks & Watchers ---
    onMounted(() => {
      const tournamentId = route.params.id;
      if (tournamentId) {
        fetchTournamentBracket(tournamentId);
      }
      // Check for bye matches after mounting
      if (rounds.value.length > 0) {
        checkAndHandleByes();
      }
    });

    // Watch for changes in tournament ID from route parameters
    watch(() => route.params.id, (newId) => {
      if (newId) {
        fetchTournamentBracket(newId);
      }
    });

    // Watch for changes in match data to update tournament positions
    watch(rounds, () => {
      updateTournamentPositions();
      // Do not call checkAndHandleByes() here to prevent infinite recursion
    }, { deep: true });

    // Check for and handle bye matches whenever the bracket structure changes  
    const checkAndHandleByes = () => {
      // Flag to prevent recursive updates
      let isHandlingByes = false;
      if (isHandlingByes) return;
      
      try {
        isHandlingByes = true;
        // Check each match in each round
        rounds.value.forEach((round, roundIndex) => {
          round.matches.forEach((match, matchIndex) => {
            // If the match has team1 but team2 is BYE, automatically set team1 as winner
            if (match.team1 && (!match.team2 || (match.team2 && match.team2.id === 'BYE'))) {
              match.hasBye = true;
              match.winner = match.team1;
              match.completed = true;
              match.score1 = 0;
              match.score2 = 0;
              // Instead of calling updateMatch (which triggers reactivity),
              // directly update the nextMatch if there is one
              if (roundIndex < rounds.value.length - 1) {
                const nextRoundIndex = roundIndex + 1;
                const nextMatchIndex = Math.floor(matchIndex / 2);
                if (nextRoundIndex < rounds.value.length && 
                    nextMatchIndex < rounds.value[nextRoundIndex].matches.length) {
                  const nextMatch = rounds.value[nextRoundIndex].matches[nextMatchIndex];
                  const isFirstFeeder = matchIndex % 2 === 0;
                  if (isFirstFeeder) {
                    nextMatch.team1 = match.winner;
                  } else {
                    nextMatch.team2 = match.winner;
                  }
                  
                  // Check if we just created a bye match in the next round too
                  if (nextMatch.team1 && nextMatch.team2 && 
                      (nextMatch.team2.id === 'BYE' || nextMatch.team1.id === 'BYE')) {
                    nextMatch.hasBye = true;
                    nextMatch.winner = nextMatch.team2.id === 'BYE' ? nextMatch.team1 : nextMatch.team2;
                    nextMatch.completed = true;
                    nextMatch.score1 = 0;
                    nextMatch.score2 = 0;
                    
                    // Continue the propagation recursively for higher rounds
                    if (nextRoundIndex < rounds.value.length - 1) {
                      const nextNextRoundIndex = nextRoundIndex + 1;
                      const nextNextMatchIndex = Math.floor(nextMatchIndex / 2);
                      if (nextNextRoundIndex < rounds.value.length && 
                          nextNextMatchIndex < rounds.value[nextNextRoundIndex].matches.length) {
                        const nextNextMatch = rounds.value[nextNextRoundIndex].matches[nextNextMatchIndex];
                        const isFirstFeeder = nextMatchIndex % 2 === 0;
                        if (isFirstFeeder) {
                          nextNextMatch.team1 = nextMatch.winner;
                        } else {
                          nextNextMatch.team2 = nextMatch.winner;
                        }
                      }
                    }
                  }
                }
              }
            }
          });
        });
      
        // Add another pass to handle any potential third place matches
        const finalRound = rounds.value[rounds.value.length - 1];
        const thirdPlaceMatch = finalRound?.matches.find(match => match.isThirdPlace);
        if (thirdPlaceMatch) {
          // Set up semifinal losers to third place match if not already set
          const semiFinalRound = rounds.value[rounds.value.length - 2];
          const semiFinalMatches = semiFinalRound.matches.filter(m => !m.isThirdPlace);
          
          // Look for completed semifinals with losers
          semiFinalMatches.forEach((match, idx) => {
            if (match.completed && match.winner) {
              const loser = match.team1 && match.team2 ? 
                             (match.winner.id === match.team1.id ? match.team2 : match.team1) : 
                             null;
              
              if (loser) {
                if (idx === 0 && !thirdPlaceMatch.team1) {
                  thirdPlaceMatch.team1 = loser;
                } else if (idx === 1 && !thirdPlaceMatch.team2) {
                  thirdPlaceMatch.team2 = loser;
                }
              }
            }
          });
          
          // Handle bye in third place match
          if (thirdPlaceMatch.team1 && thirdPlaceMatch.team2 && 
              (thirdPlaceMatch.team1.id === 'BYE' || thirdPlaceMatch.team2.id === 'BYE')) {
            thirdPlaceMatch.hasBye = true;
            thirdPlaceMatch.winner = thirdPlaceMatch.team1.id === 'BYE' ? thirdPlaceMatch.team2 : thirdPlaceMatch.team1;
            thirdPlaceMatch.completed = true;
            thirdPlaceMatch.score1 = 0;
            thirdPlaceMatch.score2 = 0;
          }
        }
      
        // Update tournament statistics after handling byes
        updateTournamentPositions();
      } finally {
        isHandlingByes = false;
      }
    };

    return {
      // State & Data
      teams, rounds, teamName, bracketGenerated, error, loading,
      zoomLevel, activeTab, teamInputRef, bracketContainerRef,
      tournamentName, tournamentStats, teamGoals,
      route, router, // Add Vue Router objects
      
      // Methods
      addTeam, generateBracket, handleKeyDown, updateMatch, updateDateTime,
      updateMatchTopScorer, updateTopScorerName, updateTopScorerGoals,
      resetBracket, saveTournamentChanges, publishTournament,
      handleZoomIn, handleZoomOut, goBack, fetchTournamentBracket,
      calculateRounds, calculateByes, getRoundNamePreview, checkAndHandleByes,
      
      // Computed
      getTotalMatches, getByeCount, getTournamentProgress, getRemainingMatches,
      
      // Style Helpers
      getMatchCardColor, getMatchCardBorder, getRoundName
    };
  }
};
</script>

<style scoped>
  /* ... */
</style>